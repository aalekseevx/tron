\begin{problem}{Игра "Трон"}{standard input}{standard output}{1 секунда на ход}{256 мегабайт}

\par Игровое поле представляет из себя матрицу размером $n \times m$ клеток. Всего в игре $10$ игровых полей. $5$ из них доступны вам для проведения дуэлей, остальные останутся вам неизвестны. Турниры будут проходить на всех $10$ полях.

\par В начальный момент времени игроки находятся на своих стартовых позициях. Стартовые позиции могут отличаться на разных картах.
Игроки ходят по очереди. Каждый ход (здесь и далее, ход - одно перемещение фишки игрока) они могут перейти в соседнею по стороне клетку, которая не была посещена кем либо ранее и в которой не содержится препятсвия.

\par За каждую посещённую клетку игрок получает $1$ очко. За каждую посещённую клетку с монетой
игрок получает дополнительно $2$ очка.


\par Также на поле в заранее определённых местах находятся бонусы двух типов
\begin{itemize}
    \item Ускоряющий бонус увеличивает вашу скорость в $2$ раза на $20$ ходов
    \item Замедляющий бонус уменьшает вашу скорость в $2$ раза на $20$ ходов
\end{itemize}

\par Если ваша скорость в $x$ раз больше (меньше) скорости противника, то право хода вам будет предоставляться в $x$ раз чаще (реже).

\par Если игрок не может сделать ход, то игра для него заканчивается, но противник продолжает ходить. Игра заканчивается, когда оба игрока не могут сделать ход.
\par Цель игры - заработать как можно больше очков.

\InputFile

\par Для чтения входных данных на запросы программа должна использовать стандартный ввод.

    
\par В первой строке входных данных записана строка $'RED'$ или строка $'BLUE'$. Это цвет фишки вашего игрока. Красная фишка ходит первой.

\par Во второй строке записано число $k$ от $1$ до $10$ - номер карты, на которой вы играете.

\par В третьей строке записано $2$ целых числа - $n$ и $m$.
\par Затем, пока у вас есть доступные ходы действует слудующий протокол взаимодействия:
        
\par На вход подаётся матрица символов, разделённых пробелами из $n$ строк и $m$ столбцов. Это игровое поле для которого вам необходимо вывести ход.
\par Условные обозначения:
\begin{itemize}
        \item$.$ - свободная клетка
        \item$R$ - клетка с фишкой красного игрока
        \item$B$ - клетка с фишкой синего игрока
        \item$r$ - клетка, посещённая красным игроком
        \item$b$ - клетка, посещённая синим игроком
        \item$X$ - клетка с препятствием
        \item$C$ - клетка с монетой
        \item$U$ - клетка с ускоряющим бонусом
        \item$D$ - клетка с замедляющим бонусом
\end{itemize}

\par В тот момент, когда у вас не будет доступных ходов, ваша программа будет остановлена. Мы гарантируем: каждый раз, когда
    программе на вход поступило поле у неё есть хотя бы один возможный вариант хода.

 
\OutputFile

\par Для записи выходных данных на запросы программа должна использовать стандартный вывод.

\par Выведите один символ из множества $\{ L, R, U, D \}$ и последующий перенос строки.
После вывода каждой строки программа должна выполнить операцию $flush$.
    Условные обозначения:
    \begin{itemize}
            \item$L$ - ход влево
            \item$R$ - ход вправо
            \item$U$ - ход вверх
            \item$D$ - ход вниз
    \end{itemize}
              
\Examples
\begin{example}
\exmp{
RED
1
15 15
R . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . B\newline
Q . . . . . . . . . . . . . .
R . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . B W

}{
D
R
}
\end{example}

\Note 

\par В примере приведены только первые 2 итерации взаимодействия. Далее - аналогично.

\par Отправьте пример кода в систему, создайте дуэль на основе этой посылки и посмотрите визуализацию. Так вы сможете быстрее освоить механику.

\newpage
\par Пример решения на $C++$.
\begin{minted}{cpp}
#include <iostream>
#include <random>
#include <time.h>
using namespace std;
mt19937 rnd(time(0));
int get_rnd(int r) {
    return abs(int(rnd())) % r;
}
int level, n, m;
string player;

void make_move() {
    vector<vector<char>> field(n, vector<char>(m));
    int my_x = -1, my_y = -1;
    char my_ptr = player == "RED" ? 'R' : 'B';
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> field[i][j];
            if (field[i][j] == my_ptr) {
                my_x = i; my_y = j;
            }
        }
    }
    int xc[] = {0, 1, 0, -1};
    int yc[] = {-1, 0, 1, 0};
    vector<int> possible_moves;
    char lit[] = {'L', 'D', 'R', 'U'};
    char good[] = {'.', 'C', 'U', 'D'};
    for (int move = 0; move < 4; move++) {
        int nx = my_x + xc[move]; int ny = my_y + yc[move];
        if (nx >= 0 && nx < n && ny >= 0 && ny < m)
        {
            int ok = 0;
            for (char c: good) {
                    ok |= (field[nx][ny] == c);
            }
            if (ok) {
                possible_moves.push_back(move);
            }
        }
    }
    cout << lit[possible_moves[get_rnd(possible_moves.size())]] << endl;
    cout.flush();
}

int main() {
    cin >> player >> level >> n >> m;
    while(true) {
        make_move();
    }
}
\end{minted}

\end{problem}

\newpage
Пример решения на Python 3.
\begin{minted}{python}

\end{minted}
\newpage
Пример решения на Java.
\begin{minted}{java}

\end{minted}